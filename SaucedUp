# SaucedUp — JUCE VSTi (ready for GitHub CI)

A minimal, open-source VST3 **instrument** (VSTi) built with **JUCE + CMake**, plus **GitHub Actions** to build downloadable artifacts for **Windows** and **macOS**.

> Drop these files in a new GitHub repo. Push. Your CI will produce a `SaucedUp.vst3` you can download from each workflow run.

---

## Repo layout

```
.
├── CMakeLists.txt
├── README.md
├── Source/
│   ├── PluginProcessor.h
│   ├── PluginProcessor.cpp
│   ├── PluginEditor.h
│   └── PluginEditor.cpp
├── cmake/
│   └── CPM.cmake
└── .github/
    └── workflows/
        └── build.yml
```

---

## CMakeLists.txt

```cmake
cmake_minimum_required(VERSION 3.20)
project(SaucedUp VERSION 1.0.0)

# Use modules in /cmake
list(APPEND CMAKE_MODULE_PATH "${CMAKE_CURRENT_SOURCE_DIR}/cmake")

# Prefer statically linked runtime on Windows for easier distribution
if (MSVC)
  add_compile_options(/Zc:__cplusplus)
endif()

# Fetch JUCE via CPM (header-only helper, see cmake/CPM.cmake)
include(cmake/CPM.cmake)
CPMAddPackage(
  NAME JUCE
  GITHUB_REPOSITORY juce-framework/JUCE
  GIT_TAG 8.0.3 # You can bump this to a newer stable JUCE tag if desired
)

# JUCE requires C++17+
set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

# Plugin source files
set(SAUCEDUP_SOURCES
    Source/PluginProcessor.cpp
    Source/PluginEditor.cpp
    Source/PluginProcessor.h
    Source/PluginEditor.h
)

juce_add_plugin(SaucedUp
    COMPANY_NAME          "Lo'Getem Beatz"
    BUNDLE_ID             com.logetem.saucedup
    IS_SYNTH              TRUE
    NEEDS_MIDI_INPUT      TRUE
    IS_MIDI_EFFECT        FALSE
    VST3_CATEGORY         Instrument
    EDITOR_WANTS_KEYBOARD_FOCUS TRUE
    FORMATS               VST3
    PRODUCT_NAME          "SaucedUp"
)

# Add source files
target_sources(SaucedUp PRIVATE ${SAUCEDUP_SOURCES})

# JUCE modules we need
target_link_libraries(SaucedUp PRIVATE
    juce::juce_audio_utils
    juce::juce_audio_devices
    juce::juce_audio_formats
    juce::juce_audio_processors
    juce::juce_dsp
    juce::juce_gui_extra
    juce::juce_gui_basics
    juce::juce_core
)

# On macOS produce an Apple-notarization-friendly bundle structure
if (APPLE)
  set_target_properties(SaucedUp PROPERTIES
    XCODE_ATTRIBUTE_CODE_SIGNING_ALLOWED "NO"
    MACOSX_BUNDLE TRUE
  )
endif()

# Place built artefacts in a predictable location
set_target_properties(SaucedUp PROPERTIES
  RUNTIME_OUTPUT_DIRECTORY "${CMAKE_BINARY_DIR}/SaucedUp_artefacts/bin"
  LIBRARY_OUTPUT_DIRECTORY "${CMAKE_BINARY_DIR}/SaucedUp_artefacts/lib"
  ARCHIVE_OUTPUT_DIRECTORY "${CMAKE_BINARY_DIR}/SaucedUp_artefacts/lib"
)
```

---

## Source/PluginProcessor.h

```cpp
#pragma once
#include <JuceHeader.h>

// A very simple sine-wave voice for demonstration
class SineSound : public juce::SynthesiserSound
{
public:
    bool appliesToNote (int) override { return true; }
    bool appliesToChannel (int) override { return true; }
};

class SineVoice : public juce::SynthesiserVoice
{
public:
    bool canPlaySound (juce::SynthesiserSound* s) override { return dynamic_cast<SineSound*>(s) != nullptr; }

    void startNote (int midiNoteNumber, float velocity, juce::SynthesiserSound*, int) override
    {
        level = velocity;
        auto freq = juce::MidiMessage::getMidiNoteInHertz (midiNoteNumber);
        phaseDelta = juce::MathConstants<double>::twoPi * freq / getSampleRate();
        tailOff = 0.0;
    }

    void stopNote (float /*velocity*/, bool allowTailOff) override
    {
        if (allowTailOff) tailOff = 1.0; else clearCurrentNote();
    }

    void pitchWheelMoved (int) override {}
    void controllerMoved (int, int) override {}

    void renderNextBlock (juce::AudioBuffer<float>& outputBuffer, int startSample, int numSamples) override
    {
        if (phaseDelta == 0.0) return;
        auto* left  = outputBuffer.getWritePointer (0, startSample);
        auto* right = outputBuffer.getNumChannels() > 1 ? outputBuffer.getWritePointer (1, startSample) : nullptr;

        while (numSamples-- > 0)
        {
            auto currentSample = (float) std::sin (phase) * (float) level * (float) (tailOff > 0.0 ? tailOff : 1.0);
            phase += phaseDelta;
            if (phase >= juce::MathConstants<double>::twoPi) phase -= juce::MathConstants<double>::twoPi;

            *left++ = currentSample;
            if (right) *right++ = currentSample;

            if (tailOff > 0.0)
            {
                tailOff *= 0.99;
                if (tailOff < 0.005) { clearCurrentNote(); phaseDelta = 0.0; break; }
            }
        }
    }

private:
    double phase { 0.0 }, phaseDelta { 0.0 };
    double level { 0.0 };
    double tailOff { 0.0 };
};

class SaucedUpAudioProcessor  : public juce::AudioProcessor
{
public:
    SaucedUpAudioProcessor();
    ~SaucedUpAudioProcessor() override = default;

    // Boilerplate
    void prepareToPlay (double sampleRate, int samplesPerBlock) override;
    void releaseResources() override {}
    bool isBusesLayoutSupported (const BusesLayout& layouts) const override;

    void processBlock (juce::AudioBuffer<float>&, juce::MidiBuffer&) override;

    juce::AudioProcessorEditor* createEditor() override;
    bool hasEditor() const override { return true; }

    const juce::String getName() const override { return "SaucedUp"; }

    bool acceptsMidi() const override { return true; }
    bool producesMidi() const override { return false; }
    bool isMidiEffect() const override { return false; }
    double getTailLengthSeconds() const override { return 0.0; }

    int getNumPrograms() override { return 1; }
    int getCurrentProgram() override { return 0; }
    void setCurrentProgram (int) override {}
    const juce::String getProgramName (int) override { return {}; }
    void changeProgramName (int, const juce::String&) override {}

    void getStateInformation (juce::MemoryBlock&) override {}
    void setStateInformation (const void*, int) override {}

private:
    juce::Synthesiser synth;
    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (SaucedUpAudioProcessor)
};

// Factory methods JUCE expects
juce::AudioProcessor* JUCE_CALLTYPE createPluginFilter();
```

---

## Source/PluginProcessor.cpp

```cpp
#include "PluginProcessor.h"
#include "PluginEditor.h"

SaucedUpAudioProcessor::SaucedUpAudioProcessor()
: juce::AudioProcessor (BusesProperties().withOutput ("Output", juce::AudioChannelSet::stereo(), true))
{
    for (int i = 0; i < 8; ++i)
        synth.addVoice (new SineVoice());
    synth.addSound (new SineSound());
}

void SaucedUpAudioProcessor::prepareToPlay (double sampleRate, int samplesPerBlock)
{
    juce::ignoreUnused (samplesPerBlock);
    synth.setCurrentPlaybackSampleRate (sampleRate);
}

bool SaucedUpAudioProcessor::isBusesLayoutSupported (const BusesLayout& layouts) const
{
    return layouts.getMainOutputChannelSet() == juce::AudioChannelSet::stereo();
}

void SaucedUpAudioProcessor::processBlock (juce::AudioBuffer<float>& buffer, juce::MidiBuffer& midi)
{
    juce::ScopedNoDenormals noDenormals;
    buffer.clear();
    synth.renderNextBlock (buffer, midi, 0, buffer.getNumSamples());
}

juce::AudioProcessorEditor* SaucedUpAudioProcessor::createEditor()
{
    return new juce::GenericAudioProcessorEditor (*this); // simple UI for now
}

juce::AudioProcessor* JUCE_CALLTYPE createPluginFilter()
{
    return new SaucedUpAudioProcessor();
}
```

---

## Source/PluginEditor.h

```cpp
#pragma once
#include <JuceHeader.h>
class SaucedUpAudioProcessor;

class SaucedUpAudioProcessorEditor  : public juce::AudioProcessorEditor
{
public:
    explicit SaucedUpAudioProcessorEditor (SaucedUpAudioProcessor& p) : juce::AudioProcessorEditor (&p) { setSize (400, 300); }
    void paint (juce::Graphics& g) override { g.fillAll (juce::Colours::black); g.setColour (juce::Colours::white); g.setFont (24.0f); g.drawFittedText ("SaucedUp VSTi", getLocalBounds(), juce::Justification::centred, 1); }
    void resized() override {}
};
```

---

## Source/PluginEditor.cpp

```cpp
#include "PluginEditor.h"
```

---

## cmake/CPM.cmake

```cmake
# Minimal CPM.cmake bootstrap (MIT) — fetches dependencies via CMake
# Source: https://github.com/cpm-cmake/CPM.cmake (trimmed bootstrap)
if(NOT CPM_SOURCE_CACHE)
  set(CPM_SOURCE_CACHE "${CMAKE_BINARY_DIR}/cpm-cache" CACHE STRING "CPM source cache")
endif()
if(NOT DEFINED CPM_DOWNLOAD_VERSION)
  set(CPM_DOWNLOAD_VERSION 0.38.7)
endif()
set(CPM_DOWNLOAD_LOCATION "${CMAKE_BINARY_DIR}/cmake/CPM_${CPM_DOWNLOAD_VERSION}.cmake")
if(NOT (EXISTS ${CPM_DOWNLOAD_LOCATION}))
  file(DOWNLOAD
    https://raw.githubusercontent.com/cpm-cmake/CPM.cmake/v${CPM_DOWNLOAD_VERSION}/cmake/CPM.cmake
    ${CPM_DOWNLOAD_LOCATION}
    TLS_VERIFY ON
  )
endif()
include(${CPM_DOWNLOAD_LOCATION})
```

> If your corporate network blocks external downloads, swap CPM for a git submodule of JUCE.

---

## .github/workflows/build.yml

```yaml
name: Build VST3 (Windows & macOS)

on:
  push:
    branches: [ main, master ]
  pull_request:
  workflow_dispatch:

jobs:
  build:
    name: ${{ matrix.os }}
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        os: [windows-latest, macos-13]

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          submodules: recursive

      - name: Set up CMake
        uses: jwlawson/actions-setup-cmake@v2

      - name: Configure (CMake + Ninja)
        run: |
          cmake -S . -B build -G Ninja -DCMAKE_BUILD_TYPE=Release

      - name: Build
        run: |
          cmake --build build --config Release --parallel

      - name: Locate artefact path
        id: locate
        shell: bash
        run: |
          # JUCE creates a VST3 directory; find it across platforms
          path=$(find build -type d -name VST3 | head -n 1)
          echo "vst3dir=$path" >> $GITHUB_OUTPUT

      - name: Upload artefact
        if: steps.locate.outputs.vst3dir
        uses: actions/upload-artifact@v4
        with:
          name: SaucedUp-${{ runner.os }}-VST3
          path: |
            ${{ steps.locate.outputs.vst3dir }}/Release/*.vst3
            ${{ steps.locate.outputs.vst3dir }}/*.vst3
```

---

## README.md

````markdown
# SaucedUp — VSTi (JUCE + CMake)

A minimal VST3 **instrument** that plays a sine wave. Built with [JUCE](https://juce.com/) using CMake and compiled in GitHub Actions for Windows and macOS.

## Quick start (local)

### Prereqs
- C++ compiler (MSVC on Windows, Xcode CLT on macOS)
- CMake ≥ 3.20
- Ninja (optional, recommended)

### Build
```bash
cmake -S . -B build -G Ninja -DCMAKE_BUILD_TYPE=Release
cmake --build build --config Release --parallel
````

The VST3 will be in `build/**/VST3/Release/`.

## GitHub CI

* Push this repo to GitHub.
* Go to **Actions** → **Build VST3**. Each run uploads a `SaucedUp.vst3` artefact for your OS.

## DAW install

* **Windows**: Copy `SaucedUp.vst3` to `%COMMONPROGRAMFILES%/VST3/`.
* **macOS**: Copy `SaucedUp.vst3` to `/Library/Audio/Plug-Ins/VST3/`.

## Customize

* Change plugin name and IDs in `CMakeLists.txt`.
* Replace the simple `GenericAudioProcessorEditor` with a custom UI in `PluginEditor.*`.
* Swap the `SineVoice` for a sampler or a richer synth using `juce_dsp`.

## License

MIT for project code. JUCE is under its own license; see JUCE repo.

```

---

## What you get
- ✅ A working VSTi that receives MIDI and outputs audio
- ✅ Builds locally and in GitHub Actions
- ✅ Artefacts automatically uploaded on each run
- ✅ Clean base to add your custom UI and DSP

---

## Next steps (tell me and I’ll wire it in)
- Custom UI (colors, logo, knobs)
- Distortion/Reverb/Wobble FX
- Cross‑platform installers (Inno Setup / Packages)
- Code signing & notarization for macOS
- Linux builds

```
